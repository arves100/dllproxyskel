/*
	Copyright (C) 2019 Arves100

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
	
/* Original License:
================================================================================
	Copyright 2008,2009 Luigi Auriemma

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA

    http://www.gnu.org/licenses/gpl-2.0.txt
*/

/*
	Changes made for v0.2 (Unofficial version):
		1. Added definition of _CRT_SECURE_NO_WARNINGS
		2. Forced Imagehlp link for MSVC
		3. Fixed warnings regarding conversion from int to unsigned int
		4. Fixed macro errors
		6. Updated license to GPLv3 or greater
		7. Fixed errors on CALL_FUNCTION2 and CALL_FUNCTION
		8. Replaced strcat with strcat_s
		9. Added macro for building with GCC/MSVC

	Environment tested: Microsoft Visual C++ 1916
*/
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <ctype.h>
#include "peexportlist.h"

#ifdef _MSC_VER
#pragma comment(lib, "Imagehlp.lib")
#endif

#define VER         "0.2"
#define CALLCONV    "WINAPI"    // aka __stdcall



FILE *open_file(char *fname, char *ext);
char *no_path(char *fname);
char *add_ext(char *fname, char *ext);
int yes_no(void);
void std_err(void);



    static const char C_file_p1[] =
        "// code generated by \"DLL proxy skeleton generator "VER"\", Luigi Auriemma http://aluigi.org\n"
		"// updated by Arves100, see https://github.com/arves100/dllproxyskel \n"
        "\n"
        "#define DLL_NAME    \"%s\"     // the name of the original DLL\n"
        "\n"
        "// if DLL_PATH is not defined the proxy DLL will automatically retrieve the Windows system32\n"
        "// folder of the system and will load the DLL in that location\n"
        "//#define DLL_PATH    \".\"    // if uncommented will be loaded the DLL in this current location\n"
        "//#define DLL_PATH    \"c:\\\\windows\\\\system32\"\n"
        "\n"
        "// if you want to proxify a system DLL remember to disable the header file which already exports those functions\n"
        "// for example, if you want to proxify wsock32.dll or ws2_32.dll you must uncomment the following lines:\n"
        "//   #define _WINSOCK_H\n"
        "//   #define _WINSOCK2_H\n"
        "// you can find the needed \"#define\"s in the include header files showed by your compiler when it reports the\n"
        "// \"redeclaration\" or \"previous declaration\" errors (example: winsock.h and winsock2.h)\n"
        "// if you need one or more specific functions declared in those include files you must redeclare them here\n"
        "\n"
        "// all the original functions have an additional underscore before their name so, for example,\n"
        "// the original recv function is _recv and the original one of __myfunc is ___myfunc\n"
        "\n"
        "// example of a simple recv() hooking using two different types of declarations of the function\n"
        "// available in this code so you can choose the most confortable (the resulting code IS the same):\n"
        //"//   #define RECV_FUNCTION(FUNCTION_NAME) int CALLING_CONVENTION (FUNCTION_NAME)(int s, char *buf, int len, int flags)\n"
        //"//   static RECV_FUNCTION(*_recv) = NULL;\n"
        //"//   RECV_FUNCTION(recv) {\n"
        "//   #define recv_(X) int (X)(int s, char *buf, int len, int flags)\n"
        "//   CALL_FUNCTION(recv) {\n"
        "//       len = _recv(s, buf, len, flags);\n"
        "//       return(len);\n"
        "//   }\n"
        "// or:\n"
        "//   CALL_FUNCTION2(int, recv, int s, char *buf, int len, int flags) {\n"
        "//       len = _recv(s, buf, len, flags);\n"
        "//       return(len);\n"
        "//   }\n"
        "\n"
		"\n"
		"// Macro for compiling with MSVC and GCC\n"
		"#ifndef _MSC_VER\n"
		"#define strcat_s(out, count, in) strcat(out, in)\n"
		"#define _countof(x) \n"
		"#endif"
		"#if _MSC_VER\n"
		"#define _ASM_(x) __asm { x }\n"
		"#define _ASMJMP_(x) __asm mov eax, x \\\n"
		"\t__asm jmp eax\n"
		"#else\n"
		"#define _ASM_(x) __asm__(\"\" ##x \"\");\n"
		"#define _ASMJMP_(x) __asm__(\"jmp \" *##x);\n"
		"#endif\n"
		"\n"
        "// example of compiling: gcc -o ws2_32.dll ws2_32.c -shared ws2_32.def\n"
        "//#define POP_EBP                               // uncomment if you use -fomit-frame-pointer\n"
        "#define POP_EBP     _ASM_(pop %%ebp)     // comment if you use -fomit-frame-pointer\n"
        //"// you MUST modify the above POP_EBP if you use -fomit-frame-pointer with your compiler!\n"
        "\n"
        "\n"
        "\n"
        //"//#define WINDLLSHIT   // try uncommenting here if you have problems with compiling but don't expect miracles\n"
        //"#ifndef WINDLLSHIT\n"
        "#include <stdlib.h>\n"
        "#include <string.h>\n"
        "#include <windows.h>\n"
        //"#else\n"
        //"    #define DECLARE_HANDLE(n)   typedef struct n##__{int i;}*n\n"
        //"    DECLARE_HANDLE(HINSTANCE);\n"
        //"    typedef HINSTANCE HMODULE;\n"
        //"    DECLARE_HANDLE(HWND);\n"
        //"    #define LPVOID              void *\n"
        //"    #define DWORD               unsigned int\n"
        //"    #define UINT                unsigned int\n"
        //"    #define LPCSTR              char *\n"
        //"    #define LPCTSTR             char *\n"
        //"    #define LPSTR               char *\n"
        //"    #define BOOL                int\n"
        //"    #define TRUE                1\n"
        //"    #define FALSE               0\n"
        //"    #define MAX_PATH            1024\n"
        //"    #define NULL                0\n"
        //"    #define WINAPI              __stdcall\n"
        //"    #define DLL_PROCESS_DETACH  0\n"
        //"    #define DLL_PROCESS_ATTACH  1\n"
        //"    #define DLL_THREAD_ATTACH   2\n"
        //"    #define DLL_THREAD_DETACH   3\n"
        //"    typedef int (WINAPI *FARPROC)();\n"
        //"    BOOL WINAPI FreeLibrary(HMODULE);\n"
        //"    HINSTANCE WINAPI LoadLibraryA(LPSTR);\n"
        //"    UINT WINAPI GetSystemDirectoryA(LPSTR,UINT);\n"
        //"    FARPROC WINAPI GetProcAddress(HINSTANCE,LPCSTR);\n"
        //"    BOOL WINAPI DisableThreadLibraryCalls(HMODULE);\n"
        //"    #define GetSystemDirectory GetSystemDirectoryA\n"
        //"    #define LoadLibrary LoadLibraryA\n"
        //"#endif\n"
        "\n"
        "\n"
        "\n"
		"\n"
        "HMODULE hm = NULL;\n"
        "\n"
        "#define CALLING_CONVENTION "CALLCONV"       // default for Windows DLLs, this IS important\n"
        "#define PROXY_PROTOTYPE(FUNCTION_NAME) \\\n"
        "        void (CALLING_CONVENTION FUNCTION_NAME)(void)\n"
        "#define PROXY_FUNCTION(FUNCTION_NAME) \\\n"
        "        static PROXY_PROTOTYPE(*_##FUNCTION_NAME) = NULL; \\\n"
        "        PROXY_PROTOTYPE(FUNCTION_NAME) { \\\n"
        "           POP_EBP _ASMJMP_(__##FUNCTION_NAME) \\\n"
        "        }\n"
        "#define CALL_FUNCTION(FUNCTION_NAME) \\\n"
        "        static FUNCTION_NAME##_(CALLING_CONVENTION *_##FUNCTION_NAME) = NULL; \\\n"
        "        FUNCTION_NAME##_(CALLING_CONVENTION FUNCTION_NAME)\n"
        "#define CALL_FUNCTION2(FUNCTION_RET, FUNCTION_NAME, FUNCTION_ARG1, ...) \\\n"
        "        static FUNCTION_RET (CALLING_CONVENTION *_##FUNCTION_NAME)(FUNCTION_ARG1, __VA_ARGS__) = NULL; \\\n"
        "        FUNCTION_RET CALLING_CONVENTION FUNCTION_NAME(FUNCTION_ARG1, __VA_ARGS__)\n"
        "\n"
        "\n"
        "\n";

    static const char C_file_p2[] =
        "\n"
        "BOOL InitInstance(void) {\n"
        "    char    winpath[MAX_PATH];\n"
        "\n"
        "    if(hm) return(TRUE);\n"
        "#ifdef DLL_PATH\n"
        "    strcpy(winpath, DLL_PATH);\n"
        "#else\n"
        "    GetSystemDirectory(winpath, sizeof(winpath));\n"
        "#endif\n"
        "    strcat_s(winpath, _countof(winpath), \"\\\\\" DLL_NAME);\n"
        "\n"
        "    hm = LoadLibrary(winpath);\n"
        "    if(!hm) return(FALSE);\n"
        "\n";

    static const char C_file_p3[] =                 
        "    return(TRUE);\n"
        "}\n"
        "\n"
        "void ExitInstance(void) {\n"
        "    if(hm) {\n"
        "        FreeLibrary(hm);\n"
        "        hm = NULL;\n"
        "    }\n"
        "}\n"
        "\n"
        "BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved) {\n"
        "    switch(fdwReason) {\n"
        "        case DLL_PROCESS_ATTACH: {\n"
        "            DisableThreadLibraryCalls(hinstDLL);\n"
        "            InitInstance();\n"
        "            break;\n"
        "        }\n"
        "        case DLL_PROCESS_DETACH: {\n"
        "            ExitInstance();\n"
        "            break;\n"
        "        }\n"
        "        default: break;\n"
        "    }\n"
        "    return(TRUE);\n"
        "}\n"
        "\n";



int main(int argc, char *argv[]) {
    PEExportList        pel;
    ExportedSymbolInfo  *pCurrent,
                        *esi,
                        xchg;
    FILE    *fdc,
            *fddef;
    unsigned int     i,
            j;
    WORD    ord;
    char    tmp[32],
            *input,
            *output,
            *func;

    fputs("\n"
        "DLL proxy skeleton generator "VER"\n"
        "by Luigi Auriemma\n"
        "e-mail: aluigi@autistici.org\n"
        "web:    aluigi.org\n"
        "\n", stdout);

    if(argc < 2) {
        printf("\n"
            "Usage: %s <input.DLL>\n"
            "\n"
            "a .C and .DEF output file with the same name of the DLL will be created here\n"
            "in the current directory\n"
            "\n", argv[0]);
        exit(1);
    }

    input  = argv[1];
    output = malloc(strlen(input) + 5);
    strcpy(output, input);

    PEExportList_init(&pel);

    printf("- open file %s\n", input);
    if(LoadExportInfo(input, &pel) < 0) {
        printf("\nError during the loading of the input file\n");
        exit(1);
    }

    fdc   = open_file(output, ".c");
    fddef = open_file(output, ".def");

    fprintf(fdc, C_file_p1, no_path(input));

    esi = calloc(pel.m_symbolCount, sizeof(ExportedSymbolInfo));
    if(!esi) std_err();

    pCurrent = NULL;
    for(i = 0; (pCurrent = PEExportList_GetNextSymbol(&pel, pCurrent)); i++) {
        esi[i].m_pszName = pCurrent->m_pszName;
        esi[i].m_ordinal = pCurrent->m_ordinal;
    }

    for(i = 0; i < (pel.m_symbolCount - 1); i++) {  // sort
        for(j = i + 1; j < pel.m_symbolCount; j++) {
            if(esi[j].m_ordinal < esi[i].m_ordinal) {
                memcpy(&xchg,   &esi[i], sizeof(ExportedSymbolInfo));
                memcpy(&esi[i], &esi[j], sizeof(ExportedSymbolInfo));
                memcpy(&esi[j], &xchg,   sizeof(ExportedSymbolInfo));
            }
        }
    }

    printf("- exported functions:\n");

    for(j = 0; j < 2; j++) {
        if(!j) {
            fprintf(fddef, "EXPORTS\n");
        } else {
            fprintf(fdc,   C_file_p2);
        }

        for(i = 0; i < pel.m_symbolCount; i++) {
            ord  = esi[i].m_ordinal;
            func = esi[i].m_pszName;
            if(!func) {
                sprintf(tmp, "ordinal_%hu", ord);
                func = tmp;
            }

            if(!j) {
                printf("  %-5hu %s\n", ord, func);

                fprintf(fdc,
                    "PROXY_FUNCTION(%s)\n",
                    func);

                fprintf(fddef,
                    "  %s @%hu\n",
                    func, ord);

            } else {
                if(func == tmp) {
                    fprintf(fdc,
                        "    _%s = (void *)GetProcAddress(hm, (LPCSTR)%hu);\n",
                        func, ord);
                } else {
                    fprintf(fdc,
                        "    _%s = (void *)GetProcAddress(hm, \"%s\");\n",
                        func, func);
                }
            }
        }
    }

    fprintf(fdc, C_file_p3);

    fclose(fdc);
    fclose(fddef);

    PEExportList_init(&pel);

    printf(
        "- done\n"
        "- now you MUST edit the output C file for modifying the prototypes of the\n"
        "  functions you want to hook following the guidelines available in the\n"
        "  comments of the generated C file\n");
    return(0);
}



FILE *open_file(char *fname, char *ext) {
    FILE        *fd;

    fname = add_ext(fname, ext);
    printf("- create file %s\n", fname);

    fd = fopen(fname, "rb");
    if(fd) {
        fclose(fd);
        printf("- do you want to overwrite the file (y/n)? ");
        if(yes_no() == 'n') exit(1);
    }
    fd = fopen(fname, "wb");
    if(!fd) std_err();
    return(fd);
}



char *no_path(char *fname) {
    char        *p;

    p = strrchr(fname, '\\');
    if(!p) p = strrchr(fname, '/');
    if(p) return(p + 1);
    return(fname);
}



char *add_ext(char *fname, char *ext) {
    char        *p;

    fname = no_path(fname);
    p = strrchr(fname, '.');
    if(!p) p = fname + strlen(fname);
    strcpy(p, ext);
    return(fname);
}



int yes_no(void) {
    int         yn;

    for(;;) {
        yn = tolower(fgetc(stdin));
        if(yn == 'y') return('y');
        if(yn == 'n') return('n');
    }
}



void std_err(void) {
    perror("\nError");
    exit(1);
}


